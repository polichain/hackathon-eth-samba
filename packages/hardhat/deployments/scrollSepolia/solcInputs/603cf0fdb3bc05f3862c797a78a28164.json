{
  "language": "Solidity",
  "sources": {
    "contracts/Rent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ncontract Rent {\n\tbool private locked;\n\n\tstruct Contract {\n\t\taddress payable renter;\n\t\taddress payable locator;\n\t\tuint insuranceAmount;\n\t\tuint rentAmount;\n\t\tuint definedTime;\n\t\tuint timeRemaining;\n\t\tContractState state;\n\t}\n\n\tmapping(address => Contract) public rentContracts;\n\n\tenum ContractState {\n\t\tUninitialized,\n\t\tStandBy,\n\t\tActive,\n\t\tAborted,\n\t\tCompleted\n\t}\n\tContractState public state;\n\n\tevent RentPaid(address indexed payer, uint amount);\n\tevent InsurancePaid(\n\t\taddress indexed payer,\n\t\tuint amount,\n\t\taddress indexed receiver\n\t);\n\tevent ContractAborted(address indexed sender);\n\tevent ContractCompleted();\n\n\t//modifier onlyRenter() {\n\t//require(msg.sender == renter, \"Only the renter can perform this action\");\n\t//_;\n\t//}\n\n\t// modifier onlyActiveContract() {\n\t// require(state == ContractState.Active, \"Contract is not active\");\n\t//_;\n\t// }\n\n\tmodifier noReentrancy() {\n\t\trequire(!locked, \"No reentrancy\");\n\t\tlocked = true;\n\n\t\t_;\n\t\tlocked = false;\n\t}\n\n\tfunction createNewContract(\n\t\taddress payable _renter,\n\t\tuint _insuranceAmount,\n\t\tuint _rentAmount,\n\t\tuint _definedTime\n\t) external {\n\t\t// Ideally, include access control here (e.g., only the admin or locator can create a new contract)\n\n\t\tContract storage newContract = rentContracts[_renter];\n\t\tnewContract.renter = _renter;\n\t\tnewContract.locator = payable(msg.sender); // Assuming msg.sender is the locator\n\t\tnewContract.insuranceAmount = _insuranceAmount;\n\t\tnewContract.rentAmount = _rentAmount;\n\t\tnewContract.definedTime = _definedTime;\n\t\tnewContract.timeRemaining = _definedTime;\n\t\tnewContract.state = ContractState.StandBy;\n\t}\n\n\tfunction payRent() public payable noReentrancy {\n\t\trequire(\n\t\t\trentContracts[msg.sender].state == ContractState.Active,\n\t\t\t\"The contract is not active\"\n\t\t);\n\t\trentContracts[msg.sender].locator.transfer(msg.value);\n\n\t\trentContracts[msg.sender].timeRemaining--;\n\n\t\tif (rentContracts[msg.sender].timeRemaining == 0) {\n\t\t\trentContracts[msg.sender].state = ContractState.Completed;\n\t\t\treceiveInsurance(msg.sender);\n\t\t\temit ContractCompleted();\n\t\t}\n\t\temit RentPaid(msg.sender, msg.value);\n\t}\n\n\tfunction abortContract() public payable noReentrancy {\n\t\trequire(\n\t\t\trentContracts[msg.sender].state == ContractState.Active,\n\t\t\t\"The contract is not active\"\n\t\t);\n\t\trequire(\n\t\t\trentContracts[msg.sender].renter == msg.sender ||\n\t\t\t\trentContracts[msg.sender].locator == msg.sender,\n\t\t\t\"Only the renter or locator can abort the contract\"\n\t\t);\n\n\t\tuint time_percentage = (rentContracts[msg.sender].definedTime * 30) /\n\t\t\t100;\n\t\tif (\n\t\t\tmsg.sender == rentContracts[msg.sender].renter &&\n\t\t\ttime_percentage >\n\t\t\t(rentContracts[msg.sender].definedTime -\n\t\t\t\trentContracts[msg.sender].timeRemaining)\n\t\t) {\n\t\t\trentContracts[msg.sender].timeRemaining = 1;\n\t\t} else {\n\t\t\trentContracts[msg.sender].state = ContractState.Aborted;\n\t\t\temit ContractAborted(msg.sender);\n\t\t}\n\n\t\treceiveInsurance(msg.sender);\n\t}\n\n\tfunction payInsurance() public payable noReentrancy {\n\t\trequire(\n\t\t\trentContracts[msg.sender].state == ContractState.StandBy,\n\t\t\t\"Contract is not in stand by\"\n\t\t);\n\t\trequire(\n\t\t\tmsg.sender == rentContracts[msg.sender].renter,\n\t\t\t\"Only the renter can do this operation\"\n\t\t);\n\t\trequire(\n\t\t\tmsg.value >= rentContracts[msg.sender].insuranceAmount,\n\t\t\t\"Insurance must be higher\"\n\t\t);\n\n\t\trentContracts[msg.sender].state = ContractState.Active;\n\t\temit InsurancePaid(msg.sender, msg.value, address(this));\n\t}\n\n\tfunction receiveInsurance(address _renter) internal {\n\t\t(bool success, ) = rentContracts[_renter].renter.call{\n\t\t\tvalue: rentContracts[_renter].insuranceAmount*10**18\n\t\t}(\"\");\n\t\trequire(success, \"transfer failed\");\n\t}\n\n\tfunction getState(address _renter) internal view returns (string memory) {\n\t\tif (rentContracts[_renter].state == ContractState.StandBy) {\n\t\t\treturn \"Stand By\";\n\t\t} else if (rentContracts[_renter].state == ContractState.Aborted) {\n\t\t\treturn \"Aborted\";\n\t\t} else if (rentContracts[_renter].state == ContractState.Completed) {\n\t\t\treturn \"Completed\";\n\t\t} else if (rentContracts[_renter].state == ContractState.Active) {\n\t\t\treturn \"Active\";\n\t\t} else {\n\t\t\treturn \"The renter don t have a contract\";\n\t\t}\n\t}\n\n\tfunction getContracts(address _user) public view returns (string memory) {\n\t\tif (rentContracts[msg.sender].renter == _user) {\n\t\t\tstring memory ContractsData = string(\n\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\"Locator address: \",\n\t\t\t\t\taddressToString(rentContracts[msg.sender].locator),\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\t\"Insurance amount: \",\n\t\t\t\t\tuintToString(rentContracts[msg.sender].insuranceAmount),\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\t\"Rent amount: \",\n\t\t\t\t\tuintToString(rentContracts[msg.sender].rentAmount),\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\t\"Contract State: \",\n\t\t\t\t\tgetState(msg.sender),\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\t\"Defined Time: \",\n\t\t\t\t\tuintToString(rentContracts[msg.sender].definedTime),\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\t\"Time remaining: \",\n\t\t\t\t\tuintToString(rentContracts[msg.sender].timeRemaining)\n\t\t\t\t)\n\t\t\t);\n\t\t\treturn ContractsData;\n\t\t} else {\n\t\t\treturn \"This address doesn't have a contract\";\n\t\t}\n\t}\n\n\tfunction getContractState(\n\t\taddress _user\n\t) public view returns (ContractState) {\n\t\treturn rentContracts[_user].state;\n\t}\n\n\tfunction getInsuranceAmount(address _renter) public view returns (uint) {\n\t\treturn rentContracts[_renter].insuranceAmount;\n\t}\n\n\tfunction getBalance() public view returns(uint){\n\t\treturn address(this).balance;\n\t}\n\n\tfunction uintToString(uint v) internal pure returns (string memory) {\n\t\tif (v == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\tuint maxlength = 100;\n\t\tbytes memory reversed = new bytes(maxlength);\n\t\tuint i = 0;\n\t\twhile (v != 0) {\n\t\t\tuint remainder = v % 10;\n\t\t\tv = v / 10;\n\t\t\treversed[i++] = bytes1(uint8(48 + remainder));\n\t\t}\n\n\t\tbytes memory s = new bytes(i);\n\t\tfor (uint j = 0; j < i; j++) {\n\t\t\ts[j] = reversed[i - j - 1];\n\t\t}\n\n\t\treturn string(s);\n\t}\n\n\tfunction addressToString(\n\t\taddress _addr\n\t) internal pure returns (string memory) {\n\t\tbytes32 _bytes = bytes32(uint256(uint160(_addr)));\n\t\tbytes memory HEX = \"0123456789abcdef\";\n\t\tbytes memory _string = new bytes(42);\n\t\t_string[0] = \"0\";\n\t\t_string[1] = \"x\";\n\t\tfor (uint i = 0; i < 20; i++) {\n\t\t\t_string[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n\t\t\t_string[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n\t\t}\n\t\treturn string(_string);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}